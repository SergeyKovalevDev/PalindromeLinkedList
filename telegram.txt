Задача "234. Palindrome Linked List" с сайта leetcode.com

Условие задачи:
Дан первый элемент head односвязного списка.
Необходимо вернуть true, если этот список является палиндромом.
Ограничения: количество узлов от 1 до 100_000, значение в узле от 0 до 9.

Решение:
1. На самом деле никакого "списка" нет, есть определение узла списка:

public class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

Таким образом можно создать несколько объектов класса ListNode, указывая в поле val значение, а в поле next следующий объект.
Например, так:

ListNode node5 = new ListNode(1);
ListNode node4 = new ListNode(2, node5);
ListNode node3 = new ListNode(3, node4);
ListNode node2 = new ListNode(2, node3);
ListNode node1 = new ListNode(1, node2);

Вот этот набор объектов и будет пониматься в дальнейшем под "списком".

2. Самой простой реализацией проверки на палиндром является попарное сравнение элементов от краев к середине.
Но так как в метод изначально передается первый элемент списка, нам неизвестно сколько всего элементов, тем более их значения.
Так как содержимое списка это примитив - значит целесообразно его преобразовать в массив.
Сделаем это используя Stream API:

int[] array = Stream
        .iterate(head, node -> node.next != null, node -> node.next)
        .mapToInt(node -> node.val).toArray();

В этой строке статический метод iterate формирует поток из объектов класса ListNode по следующим правилам:
а) первый элемент - это head;
б) лямбда функция node -> node.next != null проверяет есть ли следующий элемент, если нет, то формирование потока останавливается;
в) лямбда функция node -> node.next передает ссылку на следующий элемент.
Далее метод mapToInt(node -> node.val) делает из потока объектов класса ListNode поток примитивов int подставляя в него значения, хранящиеся в переменной val.
А метод toArray() уже формирует массив из потока.

Все бы хорошо, но в такой реализации теряется последний элемент "списка".
Происходит это потому что сначала происходит проверка есть ли следующий элемент, и на основании этого принимается решение включать ли текущий элемент в поток.

Решение следующее: заменить лямбда функцию

node -> node.next != null

на

node -> node != null

В таком случе будет проходить проверка не наличие следующего элемента, а на существование текущего.

Сама проверка на палиндром выглядит следующим образом:

boolean result = true;
for (int i = 0; i < array.length / 2; i++) {
    if (array[i] != array[array.length - 1 - i]) {
        result = false;
        break;
    }
}

В этом цикле идет попарное сравнение элементов массива от краев к середине. Если элементы не равны, то в переменную result вносится false и цикл прерывается.

Ссылка на код на Github

Вопросы, замечания и комментарии приветствуются!